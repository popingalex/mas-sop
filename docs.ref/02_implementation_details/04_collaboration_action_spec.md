# 通用协作请求 Action 规范 v1.3

## 1. 概述

`RequestCollaboration` Action 是一个为多智能体框架设计的通用能力 (Capability/Action)。其目的是提供一个标准化的机制，允许任何继承自通用智能体基类 (如 `AgentBaseRole`) 的智能体在执行复杂任务并进行内部规划时，将其无法独立完成的子任务委派给其他指定的智能体请求协助。

此 Action 封装了**协作请求的格式化和发送逻辑**。它**不处理**阻塞等待或响应接收；这些职责由调用此 Action 的智能体 (通过其基类逻辑) 承担。

## 2. 核心概念

*   **请求者 (Requester)**: 调用此 Action 的智能体。
*   **目标智能体 (Target Agent)**: 被请求提供协助的智能体 (由其 `name` 或唯一标识符指定)。
*   **子任务 (Subtask)**: 请求者希望目标智能体执行的具体工作单元。
*   **上下文 (Context)**: 执行子任务可能需要的相关信息或数据。
*   **协作请求消息 (Collaboration Request Message)**: 一个结构化的消息 (Structured Message)，包含 `request_id`, `requester_name`, `target_name`, `subtask_description`, `context`。
*   **协作响应消息 (Collaboration Response Message)**: 目标智能体完成后发送的结构化消息，包含对应的 `request_id`, `status` (`completed`, `error`, `rejected`), `result_data` 或 `error_message`。
*   **请求 ID (`request_id`)**: 用于唯一标识一次协作请求及其响应的 ID，由本 Action 生成并返回给调用者。
*   **路由 (Routing)**: 基于框架的通信机制，目标智能体需要能够在其消息处理循环中识别并过滤出发送给它的协作请求消息（例如，通过检查消息中的 `target_name`）。

## 3. Action API 定义

`RequestCollaboration` Action 提供一个主要的执行方法 `run`。

*   **`run(target_name: str, subtask_description: str, context: Optional[dict] = None) -> dict`**
    *   **描述**: **异步地**（非阻塞）发起一个协作请求给指定的目标智能体。此方法负责构建并发送请求消息，然后立即返回。
    *   **参数**:
        *   `target_name`: 目标智能体的名称或标识符。
        *   `subtask_description`: 子任务的描述。
        *   `context` (可选): 执行子任务所需的上下文。
    *   **返回 (dict)**: 包含本次请求信息的字典：
        *   `request_id`: 本次请求生成的唯一标识。调用者需要保存此 ID 以便后续匹配响应。
        *   `status`: 初始状态，固定为 `'pending'`，表示请求已发出，等待响应。

## 4. 核心逻辑与实现要点

1.  **生成请求 ID**: 创建一个唯一的 `request_id`。
2.  **构建请求消息**: 创建一个结构化的消息 (协作请求消息)，包含生成的 `request_id`, 请求者名称, `target_name`, `subtask_description`, 和序列化后的 `context`。
3.  **发布请求**: 通过框架提供的**通信机制** (Communication Mechanism) 将请求消息发送出去 (例如，发布到共享消息池或直接发送给目标)。
4.  **返回结果**: 立即返回包含 `request_id` 和初始状态 `'pending'` 的字典。
5.  **错误处理**: 需要处理请求发送失败等异常情况，可能通过抛出异常或返回包含错误信息的字典。

## 5. 目标智能体的职责

*   **接收请求**: 目标智能体 (基于通用基类) 在其**消息处理循环** (Message Handling Loop) 的观察阶段需要监听传入的消息。
*   **过滤消息**: 它需要检查收到的消息是否为协作请求消息，并判断消息中的 `target_name` 是否与自身匹配。
*   **处理请求**: 如果匹配，目标智能体需要提取 `request_id`, `subtask_description`, `context`，并执行相应的子任务处理逻辑（这可能涉及调用自身的执行或决策方法）。
*   **构建响应消息**: 子任务完成后（成功或失败），目标智能体需要构建一个协作响应消息，包含对应的 `request_id`、最终的 `status` (`completed`, `error`, `rejected`) 以及 `result_data` 或 `error_message`。
*   **发布响应**: 通过框架的通信机制将响应消息发送回系统，以便请求者能够接收。

## 6. 与智能体基类 (如 `AgentBaseRole`) 的集成

*   请求者智能体 (基于通用基类) 在其执行逻辑中调用 `RequestCollaboration.run()`。
*   请求者智能体**必须保存** `run()` 方法返回的 `request_id`。
*   请求者智能体**需要实现等待逻辑**: 在调用 `run()` 后，它需要进入一种等待状态。在其后续的**消息处理循环**中，它需要：
    *   监听传入的消息，查找**协作响应消息**。
    *   检查响应消息中的 `request_id` 是否与它保存的 `request_id` 匹配。
    *   如果匹配，处理响应结果 (`status`, `result_data`, `error_message`)，并退出等待状态，继续其内部计划。
    *   (可选) 实现超时逻辑：如果在一定时间内未收到匹配的响应，则认为协作超时。
*   目标智能体需要实现处理协作请求并发布响应的逻辑（可能通过覆盖基类的消息处理方法或实现特定的回调）。

## 7. 实现说明

*   **重点**: Phase 1 集中实现上述简化的 Action 逻辑（发送请求）和目标智能体的响应逻辑。
*   **等待逻辑**: 请求者智能体中等待响应的具体实现方式是关键，需要结合智能体基类的状态管理和其执行/消息处理循环来设计。
*   **作为能力实现**: 此功能应作为智能体的一种能力，通过框架的标准机制提供给智能体使用。

## 8. 待讨论问题 (更新)

*   **请求者等待逻辑**: 智能体基类如何优雅地实现等待状态和响应匹配逻辑？是否需要框架级别的支持或模式？
*   **超时处理**: 请求者如何实现健壮的超时机制？
*   **目标智能体实例选择**: (如果可能存在多实例) 如何确保请求路由到正确的实例？(Phase 1 假设单实例或通过 `target_name` 可唯一确定)
*   **安全性和权限**: (保持关注)
*   **上下文序列化**: (保持关注)

--- 