# 智能体思考-执行周期的实现模式 (SAFE 框架) v1.0

## 1. 概述

本文档旨在设计如何在一个通用的、基于**消息传递和函数/工具调用**的多智能体框架下，为一个智能体（Agent）实现一个结构化的"思考-执行"周期。这个周期源自 SAFE 框架中定义的通用智能体基类 (`AgentBaseRole`) 概念，其核心是让智能体在执行任务前，能够根据任务复杂度进行不同层次的思考和规划，并可能利用标准操作规程 (SOP)。

目标是描述如何扩展这类框架的现有 Agent 类，使其能够：

1.  接收任务分配。
2.  进行初步思考，判断任务复杂度。
3.  如果任务复杂，尝试查找并利用相关的 SOP 指导规划。
4.  生成详细的内部执行计划。
5.  执行计划，包括调用已注册的函数/能力 (对应 SAFE 的 Tools/Actions) 和与其他智能体协作。
6.  管理执行状态并在完成后更新外部计划状态 (通过 `Plan Tool`)。

## 2. 基于消息/函数调用框架的挑战与机遇

这类框架的核心模型通常基于智能体处理传入消息并生成回复的循环。因此，我们需要将设计的"思考-规划-执行"逻辑无缝地嵌入到智能体处理消息和生成回复的核心流程中。

机遇在于这类框架通常提供强大的函数调用 (Function Calling) 支持和灵活的对话/消息管理机制，可以用来实现 Tools/Actions 的调用和智能体间的协作。

## 3. 核心实现思路

*   **基类扩展**: 通常需要继承框架提供的基础智能体类，并重写其核心的消息处理与回复生成方法。
*   **触发机制**: 当 Agent 收到一个可识别为"任务分配"的消息时，触发"思考-执行"流程。这需要定义清晰的消息格式或利用框架的消息处理注册机制。
*   **内部状态管理**: Agent 需要维护内部状态，至少包括：
    *   `current_task_info`: 当前正在处理的任务信息。
    *   `internal_plan`: LLM 生成的内部执行步骤列表。
    *   `plan_execution_status`: 内部计划的当前执行状态 (例如，正在执行第几步，等待协作响应等)。
    *   `pending_collaboration_id`: 如果在等待协作，记录请求 ID。
*   **核心逻辑位置**: 大部分的思考、规划和执行驱动逻辑将位于被重写的核心消息处理与回复生成方法或其调用的私有方法中。

## 4. "思考-执行"流程详解

以下是将四步流程映射到通用智能体实现的初步设计：

**步骤 1: 简单思考 (判断任务复杂度)**

*   **时机**: 在核心消息处理方法的开始处，当识别到传入消息是任务分配时。
*   **机制**:
    *   调用 LLM (可能使用特定提示) 分析任务描述。
    *   LLM 判断任务是"简单"还是"复杂"。
    *   设置内部状态 `task_complexity`。

**步骤 2: SOP 检查 (若复杂)**

*   **时机**: 如果 `task_complexity == 'complex'`。
*   **机制**:
    *   需要访问 SOP 知识库 (具体实现待定)。
    *   调用 LLM 或使用其他匹配技术，根据任务描述查找相关 SOP。
    *   将找到的 SOP 存储在内部状态 `relevant_sop`。

**步骤 3: 正式思考 (任务规划)**

*   **时机**: 在步骤 1 和 2 之后。
*   **机制**:
    *   构建发送给 LLM 的规划提示，包含任务描述、复杂度、相关 SOP、智能体可用的函数/能力描述 (通常由框架管理)。
    *   要求 LLM 输出结构化的执行计划（步骤列表，指明调用函数/能力或请求协作）。
    *   调用 LLM 获取内部执行计划。
    *   解析并存储在 `internal_plan`，初始化 `plan_execution_status`。

**步骤 4: 执行**

*   **时机**: 内部计划生成后，可能跨越多个消息处理周期。
*   **机制**:
    *   核心消息处理方法检查 `plan_execution_status`。
    *   **执行函数/能力调用**:
        *   如果当前步骤是调用函数/能力，消息处理方法的返回值应包含一个结构化的函数调用请求。
        *   框架或其他组件执行函数调用，并将结果通过新消息发送回来。
        *   Agent 在下次处理消息时收到函数调用结果，更新 `internal_plan` 状态，继续下一步。
    *   **执行协作请求 (`RequestCollaboration`)**:
        *   如果当前步骤是协作请求，Agent 调用一个已注册的函数 `request_collaboration_func` (该函数实现 `RequestCollaboration` v1.3 逻辑)。
        *   消息处理方法返回对 `request_collaboration_func` 的调用请求。
        *   收到函数结果 (含 `request_id`) 后，Agent 更新内部状态为"等待协作"，记录 `pending_collaboration_id`。
        *   在后续消息处理中，Agent 优先检查收到的消息是否是等待的协作响应。
        *   收到响应后，处理结果，更新 `internal_plan` 状态，继续执行。
        *   需要实现超时逻辑。
    *   **计划完成**: 当 `internal_plan` 所有步骤完成时：
        *   调用 `Plan Tool` (通过注册的函数 `update_plan_tool_status_func`) 更新状态。
        *   核心消息处理方法返回最终结果或确认。
        *   重置内部状态。

## 5. 关键实现考虑

*   **状态持久化**: 基于消息轮次的框架通常需要特别考虑如何跨轮次维护智能体的内部执行状态 (`internal_plan`, `plan_execution_status`)。可能的方案包括：
    *   状态编码到消息历史中（可能限制复杂性）。
    *   实现有状态的智能体对象。
    *   使用外部存储。
*   **回复策略**: 核心消息处理方法在执行内部计划的不同阶段应返回什么？
    *   请求函数调用时：返回结构化的调用请求。
    *   等待协作时：返回表明等待状态的消息。
    *   处理完中间步骤后：可能不立即回复，或回复中间状态。
    *   最终完成时：返回最终结果。
*   **错误处理**: 需要健壮地处理 LLM 规划失败、函数调用错误、协作超时等，并更新状态。
*   **SOP 访问机制**: 需要设计 SOP 数据的加载和访问方式。
*   **与 Plan Tool/ArtifactManager 集成**: 需要将这些工具的 API 包装成函数，并通过框架的机制注册给 Agent。

## 6. 后续步骤

*   细化内部状态 `AgentState` 的数据结构。
*   设计 `internal_plan` 的具体格式。
*   确定状态持久化的具体方案。
*   编写更详细的核心消息处理伪代码或流程图。
*   设计与注册函数的交互细节。 